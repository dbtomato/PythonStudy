---
title: threading 模块函数列表
tags: threading,函数,列表,Thread,Lock,RLock,Condition
renderNumberedHeading: true
grammar_cjkRuby: true
---

Author:  Qiao My
Create_Time: 2020-3-21

[toc]

> 官档：[threading --- 基于线程的并行](https://docs.python.org/zh-cn/3/library/threading.html)
# threading 模块函数
| 方法 | 描述 |
| --- | --- |
| active_count() | 返回当前存活的线程类 Thread 对象。返回的计数等于 enumerate() 返回的列表长度。 |
| current_thread() | 返回当前对应调用者的控制线程的 Thread 对象。如果调用者的控制线程不是利用 threading 创建，会返回一个功能受限的虚拟线程对象。 |
| excepthook(args, /) | 处理Thread.run() 引发的未捕获异常。 |
| get_ident() | 返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。 |
| get_native_id() | 返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。可用性: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX。 |
| enumerate() | 以列表形式返回当前所有存活的 Thread 对象。 该列表包含守护线程，current_thread() 创建的虚拟线程对象和主线程。它不包含已终结的线程和尚未开始的线程。 |
| main_thread() | 返回主 Thread 对象。一般情况下，主线程是 Python解释器开始时创建的线程。 |
| settrace(func) | 为所有 threading 模块开始的线程设置追踪函数。在每个线程的 run() 方法被调用前，func 会被传递给 sys.settrace() 。 |
| setprofile(func) | 为所有 threading 模块开始的线程设置性能测试函数。在每个线程的 run() 方法被调用前，func 会被传递给 sys.setprofile() 。 |
| stack_size([size]) | 返回创建线程时用的堆栈大小。可选参数 size 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果 size 没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 RuntimeError 错误。如果指定的堆栈大小不合法，会抛出 ValueError 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器有足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）。 |
| TIMEOUT_MAX | 常量。阻塞函数（ Lock.acquire(), RLock.acquire(), Condition.wait(), ...）中形参 timeout 允许的最大值。传入超过这个值的 timeout 会抛出 OverflowError 异常。 |
| class threading.local | 一个代表线程本地数据的类。线程本地数据是特定线程的数据。管理线程本地数据，只需要创建一个 local （或者一个子类型）的实例并在实例中储存属性 |


# 线程对象函数 Thread
| 方法 | 描述 |
| --- | --- |
| start() | 开始线程活动。它在一个线程里最多只能被调用一次。它安排对象的 run() 方法在一个独立的控制进程中调用。如果同一个线程对象中调用这个方法的次数大于一次，会抛出 RuntimeError 。 |
| run() | 代表线程活动的方法。你可以在子类型里重载这个方法。 标准的 run() 方法会对作为 target 参数传递给该对象构造器的可调用对象（如果存在）发起调用，并附带从 args 和 kwargs 参数分别获取的位置和关键字参数。 |
| join(timeout=None) | 等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 join() 的线程终结 -- 不管是正常终结还是抛出未处理异常 -- 或者直到发生超时，超时选项是可选的。当 timeout 参数存在而且不是 None 时，它应该是一个用于指定操作超时的以秒为单位的浮点数（或者分数）。因为 join() 总是返回 None ，所以你一定要在 join() 后调用 is_alive() 才能判断是否发生超时 -- 如果线程仍然存货，则 join() 超时。当 timeout 参数不存在或者是 None ，这个操作会阻塞直到线程终结。一个线程可以被 join() 很多次。如果尝试加入当前线程会导致死锁， join() 会引起 RuntimeError 异常。如果尝试 join() 一个尚未开始的线程，也会抛出相同的异常。 |
| name | 只用于识别的字符串。它没有语义。多个线程可以赋予相同的名称。 初始名称由构造函数设置。 |
| getName()、setName() | 旧的 name 取值/设值 API；直接当做特征属性使用它。 |
| ident | 这个线程的 '线程标识符'，如果线程尚未开始则为 None 。这是个非零整数。参见 get_ident() 函数。当一个线程退出而另外一个线程被创建，线程标识符会被复用。即使线程退出后，仍可得到标识符。 |
| native_id | 该线程的本机整数线程ID。 这是一个非负整数，如果尚未启动线程，则为None。 |
| is_alive() | 返回线程是否存活。当 run() 方法刚开始直到 run() 方法刚结束，这个方法返回 True 。模块函数 enumerate() 返回包含所有存活线程的列表。 |
| daemon | 一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 start() 前设置好，不然会抛出 RuntimeError 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 daemon = False。当没有存活的非守护线程时，整个Python程序才会退出。 |
| isDaemon()、setDaemon() | 旧的 name 取值/设值 API；建议直接当做特征属性使用它。 |


# 锁对象函数 Lock
| 方法 | 描述 |
| --- | --- |
| acquire(blocking=True, timeout=-1) | 可以阻塞或非阻塞地获得锁。当调用时参数 blocking 设置为 True （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 True 。在参数 blocking 被设置为 False 的情况下调用，将不会发生阻塞。如果调用时 blocking 设为 True 会阻塞，并立即返回 False ；否则，将锁锁定并返回 True。当浮点型 timeout 参数被设置为正值调用时，只要无法获得锁，将最多阻塞 timeout 设定的秒数。timeout 参数被设置为 -1 时将无限等待。当 blocking 为 false 时，timeout 指定的值将被忽略。如果成功获得锁，则返回 True，否则返回 False (例如发生 超时 的时候)。 |
| release() | 释放一个锁。这个方法可以在任何线程中调用，不单指获得锁的线程。当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。在未锁定的锁调用时，会引发 RuntimeError 异常。没有返回值。 |
| locked() | 如果获得了锁则返回真值。 |


# 递归锁对象函数 RLock
| 方法 | 描述 |
| --- | --- |
| acquire(blocking=True, timeout=-1) | 可以阻塞或非阻塞地获得锁。当无参数调用时： 如果这个线程已经拥有锁，递归级别增加一，并立即返回。否则，如果其他线程拥有该锁，则阻塞至该锁解锁。一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。当发起调用时将 blocking 参数设为真值，则执行与无参数调用时一样的操作，然后返回 True。当发起调用时将 blocking 参数设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 False；在其他情况下，执行与无参数调用时一样的操作，然后返回 True。当发起调用时将浮点数的 timeout 参数设为正值时，只要无法获得锁，将最多阻塞 timeout 所指定的秒数。 如果已经获得锁则返回 True，如果超时则返回假值。 |
| release() |  释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 RuntimeError 异常。没有返回值。 |

# 条件对象函数 Condition
**class threading.Condition(lock=None)**
| 方法 | 描述 |
| --- | --- |
| acquire(*args) | 请求底层锁。此方法调用底层锁的相应方法，返回值是底层锁相应方法的返回值。 |
| release() | 释放底层锁。此方法调用底层锁的相应方法。没有返回值。 |
| wait(timeout=None) | 等待直到被通知或发生超时。如果线程在调用此方法时没有获得锁，将会引发 RuntimeError 异常。这个方法释放底层锁，然后阻塞，直到在另外一个线程中调用同一个条件变量的 notify() 或 notify_all() 唤醒它，或者直到可选的超时发生。一旦被唤醒或者超时，它重新获得锁并返回。当提供了 timeout 参数且不是 None 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。当底层锁是个 RLock ，不会使用它的 release() 方法释放锁，因为当它被递归多次获取时，实际上可能无法解锁。相反，使用了 RLock 类的内部接口，即使多次递归获取它也能解锁它。 然后，在重新获取锁时，使用另一个内部接口来恢复递归级别。返回 True ，除非提供的 timeout 过期，这种情况下返回 False。 |
| wait_for(predicate, timeout=None) | 等待，直到条件计算为真。 predicate 应该是一个可调用对象而且它的返回值可被解释为一个布尔值。可以提供 timeout 参数给出最大等待时间。这个实用方法会重复地调用 wait() 直到满足判断式或者发生超时。返回值是判断式最后一个返回值，而且如果方法发生超时会返回 False 。 |
| notify(n=1) | 默认唤醒一个等待这个条件的线程。如果调用线程在没有获得锁的情况下调用这个方法，会引发 RuntimeError 异常。这个方法唤醒最多 n 个正在等待这个条件变量的线程；如果没有线程在等待，这是一个空操作。当前实现中，如果至少有 n 个线程正在等待，准确唤醒 n 个线程。但是依赖这个行为并不安全。未来，优化的实现有时会唤醒超过 n 个线程。注意：被唤醒的线程实际上不会返回它调用的 wait() ，直到它可以重新获得锁。因为 notify() 不会释放锁，只有它的调用者应该这样做。 |
| notify_all() | 唤醒所有正在等待这个条件的线程。这个方法行为与 notify() 相似，但并不只唤醒单一线程，而是唤醒所有等待线程。如果调用线程在调用这个方法时没有获得锁，会引发 RuntimeError 异常。 |


# 函数信号量对象
**class threading.Semaphore(value=1)**
| 方法 | 描述 |
| --- | --- |
| acquire(blocking=True, timeout=None) | 获取一个信号量。在不带参数的情况下调用时：如果在进入时内部计数器的值大于零，则将其减一并立即返回 True；如果在进入时内部计数器的值为零，则将会阻塞直到被对 release() 的调用唤醒。 一旦被唤醒（并且计数器的值大于 0），则将计数器减 1 并返回 True。 每次对 release() 的调用将只唤醒一个线程。 线程被唤醒的次序是不可确定的；当发起调用时将 blocking 设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 False；在其他情况下，执行与无参数调用时一样的操作，然后返回 True；当发起调用时如果 timeout 不为 None，则它将阻塞最多 timeout 秒。 请求在此时段时未能成功完成获取则将返回 False。 在其他情况下返回 True。 |
| release() | 释放一个信号量，将内部计数器的值增加1。当计数器原先的值为0且有其它线程正在等待它再次大于0时，唤醒正在等待的线程。 |

class threading.BoundedSemaphore(value=1)
该类实现有界信号量。有界信号量通过检查以确保它当前的值不会超过初始值。如果超过了初始值，将会引发 ValueError 异常。在大多情况下，信号量用于保护数量有限的资源。如果信号量被释放的次数过多，则表明出现了错误。没有指定时， value 的值默认为1。


# 事件对象函数
**class threading.Event**
| 方法 | 描述 |
| --- | --- |
| is_set() | 当且仅当内部旗标为时返回 True。 |
| set() | 将内部标志设置为true。所有正在等待这个事件的线程将被唤醒。当标志为true时，调用 wait() 方法的线程不会被被阻塞。 |
| clear() | 将内部标志设置为false。之后调用 wait() 方法的线程将会被阻塞，直到调用 set() 方法将内部标志再次设置为true。 |
| wait(timeout=None) | 阻塞线程直到内部变量为true。如果调用时内部标志为true，将立即返回。否则将阻塞线程，直到调用 set() 方法将标志设置为true或者发生可选的超时。当提供了timeout参数且不是 None 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。当且仅当内部旗标在等待调用之前或者等待开始之后被设为真值时此方法将返回 True，也就是说，它将总是返回 True 除非设定了超时且操作发生了超时。 |


# 定时器对象函数
**class threading.Timer(interval, function, args=None, kwargs=None)**
| 方法 | 描述 |
| --- | --- |
| cancel() | 停止定时器并取消执行计时器将要执行的操作。仅当计时器仍处于等待状态时有效。 |


# 栅栏对象函数
**class threading.Barrier(parties, action=None, timeout=None)**
栅栏类提供一个简单的同步原语，用于应对固定数量的线程需要彼此相互等待的情况。线程调用 wait() 方法后将阻塞，直到所有线程都调用了 wait() 方法。此时所有线程将被同时释放。栅栏对象可以被多次使用，但进程的数量不能改变。
| 方法 | 描述 |
| --- | --- |
| wait(timeout=None) | 冲出栅栏。当栅栏中所有线程都已经调用了这个函数，它们将同时被释放。如果提供了 timeout 参数，这里的 timeout 参数优先于创建栅栏对象时提供的 timeout 参数。函数返回值是一个整数，取值范围在0到 parties -- 1，在每个线程中的返回值不相同。可用于从所有线程中选择唯一的一个线程执行一些特别的工作。 |
| reset() | 重置栅栏为默认的初始态。如果栅栏中仍有线程等待释放，这些线程将会收到 BrokenBarrierError 异常。 |
| abort() | 将屏障置于破碎状态。 这会导致任何对wait（）的活动调用或将来的调用都失败，并出现BrokenBarrierError。 例如，如果其中一个线程需要中止，请使用此选项，以避免死锁应用程序。更好的方式是：创建栅栏时提供一个合理的超时时间，来自动避免某个线程出错。 |
| parties | 冲出栅栏所需要的线程数量。 |
| n_waiting | 当前时刻正在栅栏中阻塞的线程数量。 |
| broken | 一个布尔值，值为 True 表明栅栏为破损态。 |
| exception threading.BrokenBarrierError | 异常类，是 RuntimeError 异常的子类，在 Barrier 对象重置时仍有线程阻塞时和对象进入破损态时被引发。 |









