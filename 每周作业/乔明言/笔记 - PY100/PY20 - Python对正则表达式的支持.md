---
title: 20 - Python对正则表达式的支持
tags: 正则,re,Python,re.compile,re.match,re.search,re.findall
renderNumberedHeading: true
grammar_cjkRuby: true
---

Author:  Qiao My
Create_Time: 2020-3-19

[toc]

# 一、正则表达式模式

## 1. 字符
| 实例 |  描述 |
| --- | --- |
| .   | 匹配任意字符，除了换行符"\n"，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符，也可以使用象 `[.\n]` 的模式。 |
| `\` | 转义字符 |
| `[...]`  | 用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k' |
| `[^...]` | 不在[]中的字符：`[^abc]` 匹配除了a,b,c之外的字符。 |

## 2. 预定义字符集(可以写在`[]`中)
| 模式 | 描述 |
| --- | --- |
| \d  | 匹配一个数字字符。等价于 [0-9]。 |
| \D  | 匹配一个非数字字符。等价于 `[^0-9]`。 |
| \s  | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 `[ \f\n\r\t\v]`。 |
| \S  | 匹配任何非空白字符。等价于 `[^ \f\n\r\t\v]`。 |
| \w  | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。 |
| \W  | 匹配任何非单词字符。等价于 `[^A-Za-z0-9_]`。 |

## 3. 数量词
| 模式 | 描述 |
| --- | --- |
| `*` | 匹配0个或多个的表达式。 |
| `+` | 匹配1个或多个的表达式。 |
| `?` | 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 |
| `{n}`  | 匹配n个前面表达式。例如，"o{2}"不能匹配"Bob"中的"o"，但是能匹配"food"中的两个o。 |
| `{n,}` | 精确匹配n个前面表达式。例如，"o{2,}"不能匹配"Bob"中的"o"，但能匹配"foooood"中的所有o。`o{1,}`等价于`o+`。"o{0,}"则等价于`o*`。 |
| `{n, m}` | 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 |
| `*? +? ?? {m,n}?`| 使 `* + ? {m,n}` 变成懒惰模式(非贪婪模式) |

## 4. 边界匹配(不消耗待匹配字符串中的字符)
| 模式 | 描述 |
| --- | --- |
| `'^'` |  匹配字符串的开头（注意没有单引号） |
| `$` |  匹配字符串的末尾。 |
| `\A` | 匹配字符串开始 |
| `\b` | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
| `\B` | 匹配非单词边界。`'er\B'` 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
| `\Z` | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 |
| `\z` | 匹配字符串结束 |
| `\G` | 匹配最后匹配完成的位置。 |


## 5. 逻辑、分组
| 模式 | 描述 |
| --- | --- |
| `a| b`    | 匹配a或b |
| `(re)`    | 匹配括号内的表达式，也表示一个组 |
| `(?P<name>...)` | 分组，除了原有编号外再指定一个别名 |
| `\<number>` | 引用编号为`<number>`的分组匹配到的字符串 |
| `(?P=name)` | 引用别名为`<name>`的分组匹配到的字符串 |


## 6. 特殊构造(不作为分组)
| 模式 | 描述 |
| --- | --- |
| `(?imx)`  | 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 |
| `(?-imx)` | 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 |
| `(?: re)` | 类似 (...), 但是不表示一个组 |
| `(?imx: re)`  | 在括号中使用i, m, 或 x 可选标志 |
| `(?-imx: re)` | 在括号中不使用i, m, 或 x 可选标志 |
| `(?#...)` | 注释. |
| `(?= re)` | 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 |
| `(?! re)` | 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 |
| `(?> re)` | 匹配的独立模式，省去回溯。 |


## 7. 其他
| 模式 | 描述 |
| --- | --- |
| `\n, \t,` 等。|   匹配一个换行符。匹配一个制表符, 等 |
| `\1...\9` | 匹配第n个分组的内容。 |
| `\10` | 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 |



# 二、re 模块方法

Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。

## 1. 修饰符

| 修饰符 | 描述 |
| ------- | ---- |
| re.I |同re.IGNORECASE，使匹配对大小写不敏感 |
| re.L |同re.LOCALE，做本地化识别（locale-aware）匹配 |
| re.M |同re.MULTILINE，多行匹配，影响 `^` 和 `$` |
| re.S |同re.DOTALL，使 `.` 匹配包括换行在内的所有字符 |
| re.X |同re.VERBOSE，该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |
| re.A |同re.ASCII，让 \w, \W, \b, \B, \d, \D, \s 和 \S 只匹配ASCII，而不是Unicode。|
| re.U |同re.UNICODE，根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. |


## 2. 常用函数详解(待完善)

| 函数 | 说明 |
| --- | --- |
| compile(pattern, flags=0)                    | 编译正则表达式返回正则表达式对象                             |
| match(pattern, string, flags=0)              | 用正则表达式匹配字符串 成功返回匹配对象 否则返回None         |
| search(pattern, string, flags=0)             | 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None |
| split(pattern, string, maxsplit=0, flags=0)  | 用正则表达式指定的模式分隔符拆分字符串 返回列表              |
| sub(pattern, repl, string, count=0, flags=0) | 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 |
| fullmatch(pattern, string, flags=0)          | match函数的完全匹配（从字符串开头到结尾）版本                |
| findall(pattern, string, flags=0)            | 查找字符串所有与正则表达式匹配的模式 返回字符串的列表        |
| finditer(pattern, string, flags=0)           | 查找字符串所有与正则表达式匹配的模式 返回一个迭代器          |
| purge()                                      | 清除隐式编译的正则表达式的缓存                               |
| re.I / re.IGNORECASE                         | 忽略大小写匹配标记                                           |
| re.M / re.MULTILINE                          | 多行匹配标记                                                 |

> **说明：** 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。

例1：
```python
# 切分
re.split(r'[\s\,\;]+', 'a,b;; c  d')    # ['a', 'b', 'c', 'd']

# 分组
>>> m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
>>> m
<_sre.SRE_Match object; span=(0, 9), match='010-12345'>
>>> m.group(0)
'010-12345'
>>> m.group(1)
'010'
>>> m.group(2)
'12345'

# 分组时间
>>> t = '19:05:30'
>>> m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
>>> m.groups()
('19', '05', '30')
```

```regex
# 匹配时间
^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$
# 拆解
(?#时)^(
    0[0-9]|1[0-9]|2[0-3]|[0-9]
 )
\:(?#分)
(
    0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9]
)
\:(?#秒)
(
    0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9]
)$

# 匹配日期
'^(0\d{0,3}|1\d{3}|20[0-1][0-9]|2020)-(0?[1-9]|1[0-2])-(0?[1-9]|1[0-9]|2[0-9]|3[0-1]|)$'
# 拆解
'(?#年)
^(0\d{0,3}|1\d{3}|20[0-1][0-9]|2020)
-
(?#月)
^(0?[1-9]|1[0-2])
-
(?#日)
(0?[1-9]|1[0-9]|2[0-9]|3[0-1]|)$'
```


## 3. re 全量方法
### 3.1 re模块方法
模块定义了几个函数，常量，和一个例外。有些函数是编译后的正则表达式方法的简化版本（少了一些特性）。绝大部分重要的应用，总是会先将正则表达式编译，之后在进行操作。

在 3.6 版更改: 标志常量现在是 RegexFlag 类的实例，这个类是 enum.IntFlag 的子类。
| 方法 | 描述 |
| --- | --- |
| re.compile(pattern, flags=0) | 将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配，通过这个对象的方法 match(), search() 以及其他如下描述这个表达式的行为可以通过指定 标记 | 的值来改变。值可以是以下任意变量，可以通过位的OR操作来结合（ `|` 操作符）。 |
| re.A、re.ASCII | 让 \w, \W, \b, \B, \d, \D, \s 和 \S 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 (?a) 。注意：为了保持向后兼容， re.U 标记依然存在（还有他的同义 re.UNICODE 和嵌入形式 (?u) ) ， 但是这些在 Python 3 是冗余的，因为默认字符串已经是Unicode了（并且Unicode匹配不允许byte出现)。 |
| re.DEBUG | 显示编译时的debug信息，没有内联标记。
| re.I、re.IGNORECASE | 进行忽略大小写匹配；表达式如 [A-Z] 也会匹配小写字符。Unicode匹配（比如 Ü 匹配 ü）同样有用，除非设置了 re.ASCII 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 re.LOCALE 标记。这个相当于内联标记 (?i) 。 |
| re.L、re.LOCALE | 由当前语言区域决定 \w, \W, \b, \B 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 "习惯”，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 (?L) 。 |
| re.M、re.MULTILINE | 设置以后，样式字符 '`^`' 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 '`$`' 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，’`^`’ 匹配字符串头，'`$`' 匹配字符串尾。对应内联标记 (?m) 。 |
| re.S、re.DOTALL | 让 '.' 特殊字符匹配任何字符，包括换行符；如果没有这个标记，'.' 就匹配 除了 换行符的其他任意字符。对应内联标记 (?s) 。 | |
| re.X、re.VERBOSE | 这个标记允许你编写更具可读性更友好的正则表达式。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 `*?`, `(?:` or `(?P<…>` 分组之内。当一个行内有 # 不在字符集和转义序列，那么它之后的所有字符都是注释。 |
| re.search(pattern, string, flags=0) | 扫描整个 字符串 找到匹配样式的第一个位置，并返回一个相应的 匹配对象。如果没有匹配，就返回一个 None ； 注意这和找到一个零长度匹配是不同的。 |
| re.match(pattern, string, flags=0) | 如果 string 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 匹配对象 。 如果没有匹配，就返回 None ；注意它跟零长度匹配是不同的。注意即便是 MULTILINE 多行模式， re.match() 也只匹配字符串的开始位置，而不匹配每行开始。 |
| re.fullmatch(pattern, string, flags=0) | 如果整个 string 匹配到正则表达式样式，就返回一个相应的 匹配对象 。 否则就返回一个 None ；注意这跟零长度匹配是不同的。 |
| re.split(pattern, string, maxsplit=0, flags=0) | 用 pattern 分开 string 。 如果在 pattern 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 maxsplit 非零， 最多进行 maxsplit 次分隔， 剩下的字符全部返回到列表的最后一个元素。 |
| re.findall(pattern, string, flags=0) | 对 string 返回一个不重复的 pattern 的匹配列表， string 从左到右进行扫描，匹配按找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）。空匹配也会包含在结果里。 |
| re.finditer(pattern, string, flags=0) | pattern 在 string 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 匹配对象 。 string 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。 |
| re.sub(pattern, repl, string, count=0, flags=0) | 返回通过使用 repl 替换在 string 最左边非重叠出现的 pattern 而获得的字符串。 如果样式没有找到，则不加改变地返回 string。 repl 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，\n 会被转换为一个换行符，\r 会被转换为一个回车附，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 \& 会保持原样。 向后引用像是 \6 会用样式中第 6 组所匹配到的子字符串来替换。  |
| re.subn(pattern, repl, string, count=0, flags=0) | 行为与 sub() 相同，但是返回一个元组 (字符串, 替换次数). |
| re.escape(pattern) | 转义 pattern 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。比如 |
| re.purge() | 清除正则表达式缓存。 |
| exception re.error(msg, pattern=None, pos=None) | raise 一个例外。当传递到函数的字符串不是一个有效正则表达式的时候（比如，包含一个不匹配的括号）或者其他错误在编译时或匹配时产生。如果字符串不包含样式匹配，是不会被视为错误的。错误实例有以下附加属性：msg:未格式化的错误消息; pattern: 正则表达式样式; pos: 编译失败的 pattern 的位置索引（可以是 None ）; lineno: 对应 pos (可以是 None) 的行号; colno: 对应 pos (可以是 None) 的列号;  |


### 3.2 正则表达式对象 方法和属性(re.compile返回对象)

| 方法 | 描述 |
| --- | --- |
| Pattern.search(string[, pos[, endpos]]) | 扫描整个 string 寻找第一个匹配的位置， 并返回一个相应的 匹配对象。如果没有匹配，就返回 None ；注意它和零长度匹配是不同的。 |
| Pattern.match(string[, pos[, endpos]]) | 如果 string 的 开始位置 能够找到这个正则样式的任意个匹配，就返回一个相应的 匹配对象。如果不匹配，就返回 None ；注意它与零长度匹配是不同的。 |
| Pattern.fullmatch(string[, pos[, endpos]]) | 如果整个 string 匹配这个正则表达式，就返回一个相应的 匹配对象 。 否则就返回 None ； 注意跟零长度匹配是不同的。 |
| Pattern.split(string, maxsplit=0) | 等价于 split() 函数，使用了编译后的样式。 |
| Pattern.findall(string[, pos[, endpos]]) | 类似函数 findall() ， 使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()。 |
| Pattern.finditer(string[, pos[, endpos]]) | 类似函数 finiter() ， 使用了编译后样式，但也可以接收可选参数 pos 和 endpos ，限制搜索范围，就像 search()。 |
| Pattern.sub(repl, string, count=0) | 等价于 sub() 函数，使用了编译后的样式。 |
| Pattern.subn(repl, string, count=0) | 等价于 subn() 函数，使用了编译后的样式。 |
| Pattern.flags | 正则匹配标记。这是可以传递给 compile() 的参数，任何 (?…) 内联标记，隐性标记比如 UNICODE 的结合。 |
| Pattern.groups | 捕获组合的数量。 |
| Pattern.groupindex | 映射由 `(?P<id>)` 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。 |
| Pattern.pattern | 编译对象的原始样式字符串。 |



### 3.3 匹配对象支持的属性和方法(re.search/re.match返回对象)

匹配对象
匹配对象总是有一个布尔值 True。如果没有匹配的话 match() 和 search() 返回 None 所以你可以简单的用 if 语句来判断是否匹配

match = re.search(pattern, string)
if match:
    process(match)
匹配对象支持以下方法和属性：

| 方法 | 描述 |
| --- | --- |
| Match.expand(template) | 对 template 进行反斜杠转义替换并且返回，就像 sub() 方法中一样。转义如同 \n 被转换成合适的字符，数字引用`(\1, \2)`和命名组合`(\g<1>, \g<name>)` 替换为相应组合的内容。 |
| Match.group([group1, ...]) | 返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，一个 IndexError 索引错误就 raise。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。 |
| Match.__getitem__(g) | 这个等价于 m.group(g)。这允许更方便的引用一个匹配 |
| Match.groups(default=None) | 返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 default 参数用于不参与匹配的情况，默认为 None。 |
| Match.groupdict(default=None) | 返回一个字典，包含了所有的 命名 子组。key就是组名。 default 参数用于不参与匹配的组合；默认为 None。  |
| Match.start([group])、Match.end([group]) | 返回 group 匹配到的字串的开始和结束标号。group 默认为0（意思是整个匹配的子串）。如果 group 存在，但未产生匹配，就返回 -1 。对于一个匹配对象 m， 和一个未参与匹配的组 g ，组 g (等价于 m.group(g))产生的匹配是 `m.string[m.start(g):m.end(g)]` |
| Match.span([group]) | 对于一个匹配 m ， 返回一个二元组 `(m.start(group), m.end(group))` 。 注意如果 group 没有在这个匹配中，就返回 (-1, -1) 。group 默认为0，就是整个匹配。 |
| Match.pos | pos 的值，会传递给 search() 或 match() 的方法 a 正则对象 。这个是正则引擎开始在字符串搜索一个匹配的索引位置。 |
| Match.endpos | endpos 的值，会传递给 search() 或 match() 的方法 a 正则对象 。这个是正则引擎停止在字符串搜索一个匹配的索引位置。 |
| Match.lastindex | 捕获组的最后一个匹配的整数索引值，或者 None 如果没有匹配产生的话。比如，对于字符串 'ab'，表达式 (a)b, ((a)(b)), 和 ((ab)) 将得到 lastindex == 1 ， 而 (a)(b) 会得到 lastindex == 2 。 |
| Match.lastgroup | 最后一个匹配的命名组名字，或者 None 如果没有产生匹配的话。 |
| Match.re | 返回产生这个实例的 正则对象 ， 这个实例是由 正则对象的 match() 或 search() 方法产生的。 |
| Match.string | 传递到 match() 或 search() 的字符串。 |


## 4. 编译
在Python中使用正则表达式时，re 模块内部会做两个事情：
- 编译正则表达式，如果正则表达式字符串本身不合法，会报错
- 用编译后的正则表达式去匹配字符串

如果一个正则表达式需要大量重复使用，出于效率的考虑，可以预编译该正则表达式。
编译后生成Regular Expression 对象，由于该对象已经包含了正则表达式，所以调用对应的方式时不需要再给出正则表达式字符串。
例：
```python
>>> import re
# 编译:
>>> re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
>>> re_telephone.match('010-12345').groups()
('010', '12345')
>>> re_telephone.match('010-8086').groups()
('010', '8086')
```

# 四、正则表达式 测试工具










