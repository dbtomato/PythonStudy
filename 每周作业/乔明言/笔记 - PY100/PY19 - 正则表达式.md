---
title: 19 - 正则表达式
tags: 正则表达式,re,重复限定符,反义限定符,懒惰限定符,分组,分枝条件,反向引用,零宽断言,负向零宽断言
renderNumberedHeading: true
grammar_cjkRuby: true
---

Author:  Qiao My
Create_Time: 2020-3-20

[toc]

>正则表达式：记录文本规则的代码。
正则表达式 是用来进行文本匹配的工具。
# 一、元字符

| 符号               | 解释                                      | 示例             | 说明                                               |
| ------------------ | ----------------------------------------- | ---------------- | -------------------------------------------------- |
| `.`                | 匹配任意字符                              | b.t              | 可以匹配bat / but / b#t / b1t等                    |
| \\w                | 匹配字母/数字/下划线                      | b\\wt            | 可以匹配bat / b1t / b_t等<br>但不能匹配b#t         |
| \\s                | 匹配空白字符（包括\r、\n、\t等）          | love\\syou       | 可以匹配love you                                   |
| \\d                | 匹配数字                                  | \\d\\d           | 可以匹配01 / 23 / 99等                             |
| \\b                | 匹配单词的边界                            | \\bThe\\b        |                                                    |
| `^`                | 匹配字符串的开始                          | ^The             | 可以匹配The开头的字符串                            |
| $                  | 匹配字符串的结束                          | .exe$            | 可以匹配.exe结尾的字符串                           |
| \\W                | 匹配非字母/数字/下划线                    | b\\Wt            | 可以匹配b#t / b@t等<br>但不能匹配but / b1t / b_t等 |
| \\S                | 匹配非空白字符                            | love\\Syou       | 可以匹配love#you等<br>但不能匹配love you           |
| \\D                | 匹配非数字                                | \\d\\D           | 可以匹配9a / 3# / 0F等                             |
| \\B                | 匹配非单词边界                            | \\Bio\\B         |                                                    |
| []                 | 匹配来自字符集的任意单一字符              | [aeiou]          | 可以匹配任一元音字母字符                           |
| `[^]`              | 匹配不在字符集中的任意单一字符            | [^aeiou]         | 可以匹配任一非元音字母字符                         |
| `*`                | 匹配0次或多次                             | \\w*             |                                                    |
| +                  | 匹配1次或多次                             | \\w+             |                                                    |
| ?                  | 匹配0次或1次                              | \\w?             |                                                    |
| {N}                | 匹配N次                                   | \\w{3}            |                                                    |
| {M,}               | 匹配至少M次                               | \\w{3,}           |                                                    |
| {M,N}              | 匹配至少M次至多N次                        | \\w{3,6}          |                                                    |
| \|                 | 分支                                      | foo\|bar         | 可以匹配foo或者bar                                 |
| (?#)               | 注释                                      |                  |                                                    |
| (exp)              | 匹配exp并捕获到自动命名的组中             |                  |                                                    |
| `(?<name>exp)`     | 匹配exp并捕获到名为name的组中             |                  |                                                    |
| (?:exp)            | 匹配exp但是不捕获匹配的文本               |                  |                                                    |
| (?=exp)            | 匹配exp前面的位置                         | \\b\\w+(?=ing)     | 可以匹配I'm dancing中的danc                        |
| `(?<=exp)`         | 匹配exp后面的位置                         | (?<=\\bdanc)\\w+\\b | 可以匹配I love dancing and reading中的第一个ing    |
| (?!exp)            | 匹配后面不是exp的位置                     |                  |                                                    |
| `(?<!exp)`         | 匹配前面不是exp的位置                     |                  |                                                    |
| *?                 | 重复任意次，但尽可能少重复 | a.\*b<br>a.\*?b | 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 |
| +?                 | 重复1次或多次，但尽可能少重复 |                  |                                                    |
| ??                 | 重复0次或1次，但尽可能少重复 |                  |                                                    |
| {M,N}?             | 重复M到N次，但尽可能少重复 |                  |                                                    |
| {M,}?              | 重复M次以上，但尽可能少重复 |                  |                                                    |
| \a | 报警字符(打印它的效果是电脑嘀一声) |
| \b | 通常是单词分界位置，但如果在字符类里使用代表退格 |
| \t | 制表符，Tab |
| \r | 回车 |
| \v | 竖向制表符 |
| \f | 换页符 |
| \n | 换行符 |
| \e | Escape |
| \0nn   | ASCII代码中八进制代码为nn的字符 |
| \xnn   | ASCII代码中十六进制代码为nn的字符 |
| \unnnn | Unicode代码中十六进制代码为nnnn的字符 |
| \cN | ASCII控制字符。比如`\cC`代表Ctrl+C |
| \A  | 字符串开头(类似`^`，但不受处理多行选项的影响) |
| \Z  | 字符串结尾或行尾(不受处理多行选项的影响) |
| \z  | 字符串结尾(类似`$`，但不受处理多行选项的影响) |
| \G  | 当前搜索的开头 |
| \p{name}      | Unicode中命名为name的字符类，例如`\p{IsGreek}` |
| (?>exp)       | 贪婪子表达式 |
| `(?<x>-<y>exp)` |  平衡组 |
| (?im-nsx:exp) |  在子表达式exp中改变处理选项 |
| (?im-nsx) |  为表达式后面的部分改变处理选项 |
| `(?(exp)yes|no)`  | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no |
| (?(exp)yes)       | 同上，只是使用空表达式作为no |
| `(?(name)yes|no)` | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no |
| (?(name)yes)      | 同上，只是使用空表达式作为no |


## 1. 字符转义
如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用`\`进行转义处理.
例如想匹配小数点可以写成`\.`就可以了，因为直接写`.`会匹配任意字符；同理，想匹配圆括号必须写成`\(`和`\)`，否则圆括号被视为正则表达式中的分组。

## 2. 常用元字符
| 代码 | 说明 |
| `.`  | 匹配除换行符以外的任意字符 |
| `\w` | 匹配字母或数字或下划线或汉字 |
| `\s` | 匹配任意的空白符 |
| `\d` | 匹配数字 |
| `\b` | 匹配单词的开始或结束 |
| `^ ` | 匹配字符串的开始 |
| `$ ` | 匹配字符串的结束 |

## 3. 重复 限定符
| 代码/语法 |  说明 |
| `*`   | 重复零次或更多次 |
| `+`   | 重复一次或更多次 |
| `?`   | 重复零次或一次 |
| `{n}` | 重复n次 |
| `{n,}`  | 重复n次或更多次 |
| `{n,m}` | 重复n到m次 |

## 4. 反义 限定符
| `代码/语法 ` | 说明 |
| ---------- | --- |
| `\W ` | 匹配任意不是字母，数字，下划线，汉字的字符 |
| `\S ` | 匹配任意不是空白符的字符 |
| `\D ` | 匹配任意非数字的字符 |
| `\B ` | 匹配不是单词开头或结束的位置 |
| `[^x] `  | 匹配除了x以外的任意字符 |
| `[^aeiou] ` | 匹配除了aeiou这几个字母以外的任意字符 |


## 5. 字符类
如果想匹配没有预定义元字符的字符集合，只需要在方括号里列出它们即可。
例1：
`[aeiou]`就匹配任何一个英文元音字母，`[.?!]`匹配标点符号(`.`或`?`或`!`)。
`[0-9]`代表的含意与`\d`就是完全一致的：一位数字；同理`[a-z0-9A-Z_]`也完全等同于`\w`（如果只考虑英文的话）。
`\(?0\d{2}[) -]?\d{8}`匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。


## 6. 分枝条件
**分枝条件**是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法时用`|`把不同的规则分隔开。

例2：
`\(?0\d{2}[) -]?\d{8}` 可能会匹配到010)12345678或(022-87654321这样的“不正确”的格式。
应该改为

```regex
# 三位区号的电话号码
\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}
# 三位或四位区号的电话号码
\(0\d{2,3}\)[- ]?\d{8}|0\d{2,3}[- ]?\d{8}
```

**使用分枝条件时，要注意各个条件的顺序**。
例3：
美国邮编：5位数字，或者用连字号间隔的9位数字。
```regex
\d{5}-\d{4}|\d{5}
```
如果对调一下顺序，改为`\d{5}|\d{5}-\d{4}`，那么将匹配错误。


## 7. 分组(子表达式)
分组(子表达式)，通过小括号来指定。
例4：
IP地址匹配
```regexp
# 简单匹配，可能匹配到300.300.300.300这样的错误IP
(\d{1,3}\.){3}\d{1,3}

# 完整匹配
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
```
注意: `[01]?\d\d?` 这部分的两个`?`，`?`表示出现0或1次。
第一个字符是0，或者1，或者可以没有这个字符，第二个字符是任意一位数字，第三个字符是任意一位数字，可以没有这个字符。表示1-199，可以有前导零。
这样这个IP段数字可能为0或1开头的两位、三位数，也可能是[1-9]的个位数、两位数。

## 8. 后向引用
使用小括号指定一个子表达式后，**匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。
默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组组号为1，第二个为2，以此类推。

**后向引用** 用于重复搜索前面某个分组匹配的文本。例如`\1`代表分组1匹配的文本。

**组名** 支持自定义。格式为: `(?<重命名>限定符)` 或 `(?'重命名'限定符)`

例5：
```regexp
# 匹配重复的单词，如 go go, 或者kitty kitty。
\b(\w+)\b\s+\1\b
# 重命名组名
\b(?<Word>\w+)\b\s+\k<Word>\b
```

### 常用分组语法
| 分类    | 代码/语法 | 说明 |
| ---    | ------- | --- |
| 捕获    | (exp) |  匹配exp,并捕获文本到自动命名的组里 |
| 捕获    | `(?<name>exp)` |   匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |
| 捕获    | (?:exp)  | 匹配exp,不捕获匹配的文本到组里，也不给此分组分配组号 |
| 零宽断言 | (?=exp)  | 匹配exp前面的位置 |
| 零宽断言 | `(?<=exp)` |   匹配exp后面的位置 |
| 零宽断言 | (?!exp)  | 匹配后面跟的不是exp的位置 |
| 零宽断言 | `(?<!exp)` | 匹配前面不是exp的位置 |
| 注释    | (?#comment) | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |

## 9. 零宽断言
指定一个位置，这个位置满足一定的条件(断言)，称为**零宽断言**。

### 零宽度正预测先行断言
语法： `(?=exp)`
断言自身出现的位置的后面能匹配表达式exp。


### 零宽度正回顾后发断言
语法： `(?<=exp)`
断言自身出现的位置的前面能匹配表达式exp。

例6：
```regex
# 匹配 以ing结尾的单词的前面部分，除了ing以外的部分。
\b\w+(?=ing\b)
# 匹配 以re开头的单词的后半部分,除了re以外的部分。
(?<=\bre)\w+\b
# 匹配 以空白符间隔的数字，不包括空白符
(?<=\s)\d+(?=\s
```

## 10. 负向零宽断言
负向零宽断言：只匹配一个位置，并不**消费**任何字符。

### 零宽度负预测先行断言
语法: `(?!exp)`
断言此位置的后面不能匹配表达式exp。

### 零宽度负回顾后发断言
语法: `((?<!exp))`
断言此位置的前面不能匹配表达式exp。

例7：
```regex
# 匹配 包含后面不是字母u的字母q的单词
\b\w*q(?!u)\w*\b
# 匹配不包含连续字符串abc的单词
\b((?!abc)\w)+\b
# 匹配前面不是小写字母的七位数字
(?<![a-z])\d{7}
# 匹配不包含属性的简单HTML标签内里的内容
(?<=<(\w+)>).*(?=<\/\1>)
```

## 11. 注释
语法：`(?#comment)`
小括号的另一中用途就是通过语法来包含注释。
要包含注释，最好启用“忽略模式里的空白符”选项，这样可以在编写表达式时任意添加空格、tab、换行，而实际使用时这些都将被忽略。
启用这个选项后，在`#`后面到这一行结束的所有文本都将被当成注释忽略掉。
例8：
```regex
# 匹配IP
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)

# 匹配 不包含属性的简单HTML标签内里的内容
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的内容
        # (即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容
)       # 后缀结束
```

## 12. 贪婪与懒惰
**贪婪**匹配：在使整个表达式能得到匹配的前提下，匹配**尽可能多**的字符。
**懒惰**匹配：匹配**尽可能少**的字符。

懒惰匹配语法：在 能接受重复的限定符 后面加 `?`。

### 懒惰限定符
| 代码/语法  | 说明 |
| -------  | --- |
| *? | 重复任意次，但尽可能少重复 |
| +? | 重复1次或更多次，但尽可能少重复 |
| ?? | 重复0次或1次，但尽可能少重复 |
| {n,m}? | 重复n到m次，但尽可能少重复 |
| {n,}?  | 重复n次以上，但尽可能少重复 |

例9：
```regex
# 匹配最短的，以a开始，以b结束的字符串
a.*?b
```

## 13. 平衡组/递归匹配
Python 中并不支持 平衡组/递归匹配，需要自己实现。

以下为.net的平衡组/递归匹配 介绍。
`(?'group')` 把捕获的内容命名为group,并压入堆栈(Stack)
(`?'-group')` 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
`(?(group)yes|no)` 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
`(?!)` 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

例10：
```regex
# 把xx <aa <bbb> <bbb> aa> yy这样的字符串里，最长的配对的尖括号内的内容捕获出来
<                   #最外层的左括号
  [^<>]*            #它后面非括号的内容
  (
      (
        (?'Open'<)  #左括号，压入"Open"
        [^<>]*      #左括号后面的内容
      )+
      (
        (?'-Open'>) #右括号，弹出一个"Open"
        [^<>]*      #右括号后面的内容
      )+
  )*
  (?(Open)(?!))     #最外层的右括号前检查
                    #若还有未弹出的"Open"
                    #则匹配失败
>                #最外层的右括号
```

# 参考
[《正则表达式30分钟入门教程》](https://deerchao.net/tutorials/regex/regex.htm)
[《re --- 正则表达式操作》](https://docs.python.org/zh-cn/3/library/re.html)



