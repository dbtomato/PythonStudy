---
title: 06 | 链表（上）：如何实现LRU缓存淘汰算法?
tags: 链表,LRU,FIFO,LFU,单链表,循环链表,双向链表,双向循环链表
renderNumberedHeading: true
grammar_cjkRuby: true
---

Author:  Qiao My
Create_Time: 2020-2-29

[toc]




缓存：一种提高数据读取性能的技术，在硬件设计、软件开发中都有广泛的应用。比如常见的 CPU 缓存，数据库缓存，浏览器缓存等。

缓存淘汰策略：
FIFO : First In,First Out 先进先出
LFU  : Least Frequently Used 最少使用
LRU  : Least Recently Used 最近最少使用


# 链表
定义：
通过`指针`将一组零散的内存块串联起来。
其中，内存块成为链表的`结点`。

链表和数组的区别：
数组：需要连续的内存空间。
链表：不需要连续的内存空间

> 和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。

链表类型：
|           |  |
|  -------- | - |
| 单链表     |  |
| 循环链表    |  |
| 双向链表    |  |
| 双向循环链表 |  |


## 单链表
后继指针 next : 为了将所有`结点`串联起来，每个结点除了存储数据之外，还需要记录下一个结点的地址,这个`记录下一个结点地址的指针`叫做后继指针 next。
头结点: 链表的第 1 个结点，记录链表的`基地址`，通过头结点可以遍历得到整条链表。
尾结点: 链表的最后一个结点，指针指向`空地址 NULL`，用于表示链表上最后一个结点。

### 单链表 查找
根据结点指针，一个结点一个结点的依次遍历，时间复杂度为 O(n) 。
因为，链表的数据在内存中是非连续存储的，无法像数组那样根据首地址和下标，通过寻址公式直接计算出对应内存地址，只能逐个遍历。

### 单链表 插入
1、遍历链表得到插入位置，假如位置为 k
2、修改 k 结点指针指向新插入的结点，修改新插入结点的指针指向原 k 结点指向的结点。

### 单链表 删除
1、遍历链表得到删除结点位置，假如为 `k - 1` 结点
2、将`k - 1`的指针指向`k + 1`的结点

如图：
![](./images/1582964779113.png)


## 循环链表
循环链表：尾结点指针指向首结点的单向链表。
![](./images/1582964815094.png)
循环链表和单向链表的区别：循环链表尾结点指针指向首结点，单向链表尾结点指向空地址NULL。

循环链表 优点：
从链尾到链头比较方便。适合处理具有环型结构特点的数据，比如著名的约瑟夫问题[^1]

## 双向链表
双向链表 支持两个方向，每个结点除了一个后继指针 next，还有一个`前驱指针 prev`指向当前结点的前一个结点。
优缺点：
缺点：因为需要额外的 1 个空间存储`前驱结点 prev`的地址，所以双向链表 要比单向链表占用更多的内存空间。
优点：支持双向遍历，操作灵活。

如图：
![](./images/1582964792645.png)

### 删除
双向链表、单向链表删除操作对比
- 1、删除结点中“值等于某个给定值”的结点；
  - 双向、单向链表 均需逐个遍历链表找值等于给定值的结点，通过指针操作删除。遍历查找是主要耗时点，时间复杂度为 O(n) ，根据加法法则，最终时间复杂度均为 O(n)
- 2、删除给定指针指向的结点
  - 单向链表：删除结点需修改前驱结点指针，而单向链表无法直接找到前驱结点，因此需要从首结点开始遍历链表，直到`结点->next = 删除结点`，时间复杂度 O(n)
  - 双向链表：直接找到删除结点的前驱结点，时间复杂度 O(1)

### 插入
插入操作和删除操作同理，都需要修改插入位置结点的前驱结点，单向链表需要遍历链表找到前驱结点。

### 查找
对于有序链表，双向链表按值查询的效率比单向链表更高。
因为，可以通过记录上次查找的位置 p，每次查询时，对比要查找的值与 p的大小关系，决定查找方向向前或向后，所以平均只需查找一半的链表数据。


通过上述增删查，可以明显看出双向链表`用空间换时间`的设计思想。
缓存 实际上也是利用了空间换时间的设计思想。

## 双向循环链表
双向循环链表：循环链表和双向链表的结合。
如图：
![](./images/1582964851601.png)

# 链表 VS 数组性能对比

链表、数组时间复杂度对比：
如图：
![](./images/1582964858047.png)

数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。

- 数组
  - 优点：使用连续内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。
  - 缺点：大小固定，一经声明就要占用连续内存空间。如声明的数组过大，系统空余连续内存不足，导致“内存不足(out of memory)”。声明数组过小，则可能不够用，而数组扩容非常费时，也浪费资源。
- 链表
  - 优点：**没有大小限制，天然支持动态扩容** --> 与数组的最大区别
  - 缺点：
    非连续内存存储，对 CPU 缓存不友好，无法有效预读。
    如频繁对链表增删，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java，就可能导致频繁GC(Garbage Collection垃圾回收)

如果代码对内存使用非常苛刻，适合使用数组。

# LRU 缓存淘汰算法
思路：
维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，从链表头开始顺序遍历链表。
- 1、如果此数据之前已经被缓存在链表中，遍历得到这个结点，并将其从原来的位置删除，插入到链表的头部。
- 2、如果数据没有在缓存链表中：
  - 如果缓存未满，将此结点直接插入到链表头部
  - 如果缓存已满，则链表尾结点删除，将新的数据结点插入链表头部。

除了链表，还可以通过数组实现LRU 缓存淘汰策略。


[^1]:
    约瑟夫问题 https://zh.wikipedia.org/wiki/约瑟夫斯问题
    约瑟夫问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。
    人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。
    问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。












